PROJECT STRUCTURE AND SOURCE CODE
Generated from: C:\Users\ivans\Documents\!!!Neyasity NEW\Logger V4_SOFT\lib\FSM
==================================================

FILE TREE:
./
    FSMManager.cpp
    FSMManager.h
    FSM_Definitions.h
    project_context.txt
    StateFactory.cpp
    StateFactory.h
    states/
        State_DataSend.h
        State_NetSetup.h
        State_ScreenOn.h
        State_Sleep.h
        State_Work.h

==================================================

--- FILE: FSMManager.cpp ---
#include "FSMManager.h"
#include "StateFactory.h"
#include "AppConfig.h" 

FSMManager fsm;

void FSMManager::init(StateType initialState) {
    _changeState(initialState);
}

void FSMManager::update() {
    if (_currentState) {
        _currentState->onUpdate();
    }
}

void FSMManager::_changeState(StateType type) {
    if (_currentState) {
        if (_currentState->getType() == type) return;
        _currentState->onExit();
        delete _currentState; // Освобождаем память старого состояния
    }

    _currentState = StateFactory::createState(type);
    
    if (_currentState) {
        _currentState->onEnter();
    }
}

void FSMManager::handleEvent(FSMEvent event) {
    if (!_currentState) return;

    StateType current = _currentState->getType();

    // Глобальная логика переходов
    switch (event) {
        case FSMEvent::BTN_SHORT:
            if (current == StateType::SLEEP) _changeState(StateType::SCREEN_ON);
            else if (current == StateType::SCREEN_ON) {
                // В SCREEN_ON короткое нажатие просто меняет индекс экрана внутри DisplayUI
                // Но если это 3-й экран, можно вернуться в SLEEP или сбросить таймер
            }
            break;

        case FSMEvent::TIMEOUT:
            if (current == StateType::SCREEN_ON) _changeState(StateType::SLEEP);
            break;

        case FSMEvent::SENSOR_DONE:
            // После измерения решаем: слать данные или спать
            _changeState(StateType::SLEEP); 
            break;
            
        default:
            break;
    }
}

StateType FSMManager::getCurrentStateType() const {
    return _currentState ? _currentState->getType() : StateType::NONE;
}

--- FILE: FSMManager.h ---
#ifndef FSM_MANAGER_H
#define FSM_MANAGER_H

#include "FSM_Definitions.h"
// Do NOT include StateFactory.h here to avoid circular dependency

class BaseState; // Forward declaration

class FSMManager {
private:
    BaseState* _currentState = nullptr;
    void _changeState(StateType type);

public:
    FSMManager() {}
    void init(StateType initialState);
    void update();
    void handleEvent(FSMEvent event);
    StateType getCurrentStateType() const;
};

extern FSMManager fsm;

#endif

--- FILE: FSM_Definitions.h ---
#ifndef FSM_DEFINITIONS_H
#define FSM_DEFINITIONS_H

#include <Arduino.h>

enum class StateType {
    SLEEP,
    SCREEN_ON,
    WORK,
    DATA_SEND,
    NET_SETUP,
    NONE
};

enum class FSMEvent {
    BTN_SHORT,
    BTN_LONG,
    BTN_DOUBLE,
    SENSOR_DONE,
    SEND_SUCCESS,
    SEND_FAIL,
    SYNC_SUCCESS, // Время успешно получено
    SYNC_FAIL,
    TIMEOUT
};

// Интерфейс состояния
class BaseState {
public:
    virtual ~BaseState() {}
    virtual void onEnter() = 0;
    virtual void onUpdate() = 0; // Тик
    virtual void onExit() = 0;
    virtual StateType getType() const = 0;
};

#endif

--- FILE: project_context.txt ---


--- FILE: StateFactory.cpp ---
#include "StateFactory.h"
#include "states/State_Sleep.h"
#include "states/State_Work.h"
#include "states/State_ScreenOn.h"
#include "states/State_DataSend.h"
#include "states/State_NetSetup.h"

BaseState* StateFactory::createState(StateType type) {
    switch (type) {
        case StateType::SLEEP:     return new State_Sleep();
        case StateType::WORK:      return new State_Work();
        case StateType::SCREEN_ON: return new State_ScreenOn();
        case StateType::DATA_SEND: return new State_DataSend();
        case StateType::NET_SETUP: return new State_NetSetup();
        default: return nullptr;
    }
}

--- FILE: StateFactory.h ---
#ifndef STATE_FACTORY_H
#define STATE_FACTORY_H

#include "FSM_Definitions.h"

class StateFactory {
public:
    static BaseState* createState(StateType type);
};

#endif

--- FILE: states\State_DataSend.h ---
#ifndef STATE_DATA_SEND_H
#define STATE_DATA_SEND_H

#include "FSM_Definitions.h"
#include "AppConfig.h"
#include <WiFi.h>

// Подключаем ваши библиотеки (предполагаемые имена методов)
#include "DataLogger.h" // Нужно будет добавить методы отправки в DataLogger
#include "LoRa.h"       // Ваш класс работы с LoRa

class State_DataSend : public BaseState {
private:
    uint32_t _startTime;
    bool _wifiAttempted = false;
    bool _sentSuccess = false;

    // Вспомогательный метод для попытки подключения WiFi (короткий таймаут)
    bool connectWiFi() {
        if (WiFi.status() == WL_CONNECTED) return true;
        
        Serial.println("DataSend: Connecting WiFi...");
        WiFi.begin(AppConfig.ssid.c_str(), AppConfig.pass.c_str());
        
        uint32_t start = millis();
        while (millis() - start < 10000) { // 10 секунд на подключение
            if (WiFi.status() == WL_CONNECTED) return true;
            delay(100);
        }
        return false;
    }

    // Логика отправки через WiFi (HTTP/MQTT)
    bool sendViaWiFi() {
        if (!connectWiFi()) return false;
        
        Serial.println("DataSend: Sending via WiFi (HTTP)...");
        // Здесь вызов вашего метода из DataLogger или HTTPClient
        // bool result = DataLogger.uploadToDB(); 
        
        // ЗАГЛУШКА для примера:
        bool result = true; // Предположим, успешно
        delay(500); // Симуляция отправки
        
        return result;
    }

    // Логика отправки через LoRa
    void sendViaLoRa() {
        Serial.println("DataSend: Sending via LoRa...");
        // Инициализация LoRa, если выключена
        // LoRa.begin(...);
        
        // Отправка пакета
        // String data = DataLogger.getLastPacket();
        // LoRa.sendPacket(data);
        
        delay(200); // Время на передачу
    }

public:
    void onEnter() override {
        Serial.println("FSM: -> DATA_SEND");
        _startTime = millis();
        _wifiAttempted = false;
        _sentSuccess = false;

        // Выбор стратегии в зависимости от режима
        switch (AppConfig.mode) {
            
            // === NORMAL: WiFi, если нет -> LoRa ===
            case MODE_NORMAL:
                if (sendViaWiFi()) {
                    Serial.println("DataSend: WiFi Success");
                    _sentSuccess = true;
                } else {
                    Serial.println("DataSend: WiFi Failed -> Fallback to LoRa");
                    sendViaLoRa();
                    // Статус все равно считаем "успехом" для выхода, 
                    // так как данные ушли хотя бы по LoRa
                    _sentSuccess = true; 
                }
                break;

            // === STANDARD: Только LoRa ===
            case MODE_STANDARD:
                WiFi.mode(WIFI_OFF); // Гарантируем, что WiFi выключен
                sendViaLoRa();
                _sentSuccess = true;
                break;

            // === ECO: Отправка по кнопке (обычно WiFi) ===
            case MODE_ECO:
                // Если мы попали сюда, значит пользователь инициировал отправку
                if (sendViaWiFi()) {
                     Serial.println("DataSend: ECO Upload Success");
                     _sentSuccess = true;
                } else {
                     Serial.println("DataSend: ECO Upload Failed");
                     _sentSuccess = false;
                }
                break;

            // === SCHEDULE: Пакетная отправка ===
            case MODE_SCHEDULE:
                // Логика массовой отправки
                // sendViaLoRaBurst();
                _sentSuccess = true;
                break;
        }
    }

    void onUpdate() override {
        // Поскольку в onEnter мы использовали блокирующие вызовы (для простоты),
        // здесь мы просто проверяем завершение и выходим.
        // В более сложной системе здесь был бы конечный автомат процесса отправки.
        
        extern class FSMManager fsm;
        
        if (_sentSuccess) {
            fsm.handleEvent(FSMEvent::SEND_SUCCESS);
        } else {
            fsm.handleEvent(FSMEvent::SEND_FAIL);
        }
    }

    void onExit() override {
        Serial.println("FSM: <- DATA_SEND");
        
        // Отключаем WiFi для экономии, если не нужен
        WiFi.disconnect(true);
        WiFi.mode(WIFI_OFF);
        
        // LoRa в режим сна
        LoRa.sleep();
    }

    StateType getType() const override { return StateType::DATA_SEND; }
};

#endif

--- FILE: states\State_NetSetup.h ---
#ifndef STATE_NET_SETUP_H
#define STATE_NET_SETUP_H

#include "FSM_Definitions.h"
#include <WiFi.h>
#include "time.h"
#include "AppConfig.h" // Предполагаем, что тут хранятся SSID и PASS

class State_NetSetup : public BaseState {
private:
    uint32_t _startAttemptTime;
    const uint32_t _timeout = 15000; // 15 секунд на попытку подключения
    bool _isSyncing = false;

public:
    void onEnter() override {
        Serial.println("FSM: -> NET_SETUP (WiFi connecting...)");
        _startAttemptTime = millis();
        _isSyncing = false;

        WiFi.begin(AppConfig.ssid, AppConfig.pass);
    }

    void onUpdate() override {
        // 1. Проверка статуса подключения
        if (WiFi.status() == WL_CONNECTED) {
            if (!_isSyncing) {
                Serial.println("WiFi Connected. Syncing NTP...");
                configTime(0, 0, "pool.ntp.org", "time.nist.gov");
                _isSyncing = true;
            }

            // Проверяем, получено ли системное время (год > 1970)
            struct tm timeinfo;
            if (getLocalTime(&timeinfo)) {
                Serial.println("Time Synchronized!");
                // Сообщаем менеджеру об успехе
                extern class FSMManager fsm; 
                fsm.handleEvent(FSMEvent::SYNC_SUCCESS);
            }
        }

        // 2. Проверка тайм-аута (если WiFi не подключился за 15 сек)
        if (millis() - _startAttemptTime > _timeout) {
            Serial.println("WiFi Timeout!");
            extern class FSMManager fsm;
            fsm.handleEvent(FSMEvent::SYNC_FAIL);
        }
    }

    void onExit() override {
        Serial.println("FSM: <- NET_SETUP (Turning WiFi off)");
        WiFi.disconnect(true);
        WiFi.mode(WIFI_OFF); // Важно для энергосбережения
    }

    StateType getType() const override { return StateType::NET_SETUP; }
};

#endif

--- FILE: states\State_ScreenOn.h ---
#ifndef STATE_SCREEN_H
#define STATE_SCREEN_H

#include "FSM_Definitions.h"

class State_ScreenOn : public BaseState {
    uint32_t _startTime;
public:
    void onEnter() override {
        _startTime = millis();
        Serial.println("FSM: -> SCREEN_ON");
        // Display.show();
    }
    void onUpdate() override {
        // Если прошло больше А секунд (берем из конфига)
        // if (millis() - _startTime > AppConfig.A * 1000) { ... }
    }
    void onExit() override { /* Display.hide(); */ }
    StateType getType() const override { return StateType::SCREEN_ON; }
};

#endif

--- FILE: states\State_Sleep.h ---
#include "FSM_Definitions.h"

class State_Sleep : public BaseState {
public:
    void onEnter() override { 
        Serial.println("FSM: -> SLEEP (Entering Light Sleep)"); 
        // Настройка пробуждения по таймеру T и по кнопке
        // esp_light_sleep_start();
    }
    void onUpdate() override {} 
    void onExit() override { Serial.println("FSM: <- SLEEP (Waking up)"); }
    StateType getType() const override { return StateType::SLEEP; }
};

--- FILE: states\State_Work.h ---
#ifndef STATE_WORK_H
#define STATE_WORK_H

#include "FSM_Definitions.h"
#include "FSMManager.h" // Required for fsm.handleEvent
#include "AppConfig.h"
#include "DataLogger.h"    // Required for DataEntry and dataLogger
#include "Adafruit_AHTX0.h"

// Define or include Pinout
#ifndef ADC_BAT_PIN
#define ADC_BAT_PIN 1 // Example pin, change to actual
#endif

extern Adafruit_AHTX0 aht; 
extern DataLoggerClass dataLogger; 

class State_Work : public BaseState {
public:
    void onEnter() override {
        Serial.println("FSM: -> WORK (Measuring)");

        sensors_event_t humidity, temp;
        // Ensure 'aht' is initialized in main setup
        aht.getEvent(&humidity, &temp);

        float v_bat = (analogRead(ADC_BAT_PIN) * 3.3 / 4095.0) * 2.0; 
        int bat_pct = map(v_bat * 100, 330, 420, 0, 100);
        bat_pct = constrain(bat_pct, 0, 100);

        DataEntry entry;
        entry.timestamp = time(nullptr);
        entry.temperature = temp.temperature;
        entry.humidity = humidity.relative_humidity;
        entry.battery = bat_pct;
        
        dataLogger.write(entry);

        AppConfig.wakeCount++;
        AppConfig.save(); 

        if (AppConfig.wakeCount % AppConfig.D_netSync == 0) {
            fsm.handleEvent(FSMEvent::SENSOR_DONE); 
        } else if (AppConfig.wakeCount % AppConfig.N_sendData == 0) {
            fsm.handleEvent(FSMEvent::SENSOR_DONE); 
        } else {
            fsm.handleEvent(FSMEvent::SENSOR_DONE); 
        }
    }

    void onUpdate() override {}
    void onExit() override {}
    StateType getType() const override { return StateType::WORK; }
};

#endif

